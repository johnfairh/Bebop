<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Extensions  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    
    <script src="js/jazzy.js" defer></script>
    <link rel="stylesheet" href="css/patch.min.css">
<script src="js/patch.min.js" defer></script>
  </head>
  <body>
    
    <a title="Extensions  Reference"></a>
    <header>
  <div class="content-wrapper">
    <p><a href="index.html">SpmSwiftModule docs</a> (48% documented)</p>
    
    <p class="header-right"><a href="http://www.bbc.co.uk/"><img src="img/gh.png"/>View on GitHub</a></p>
    
    
    <p class="header-right"><a href="dash-feed://http%3A%2F%2Fwww%2Egoogle%2Ecom%2Fdocsets%2FSpmSwiftModule%2Exml"><img src="img/dash.png"/>Install in Dash</a></p>
    
  </div>
</header>

    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">SpmSwiftModule Reference</a>
        <img id="carat" src="img/carat.png" />
        Extensions  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
  <ul class="nav-groups">
    
    <li class="nav-group-name">
      <a href="guides.html?swift">Guides</a>
      <ul class="nav-group-tasks">
        
        <li class="nav-group-task">
          <a href="guides/guide.html?swift">Guide</a>
        </li>
        
      </ul>
    </li>
    
    <li class="nav-group-name">
      <a href="types.html?swift">Types</a>
      <ul class="nav-group-tasks">
        
        <li class="nav-group-task">
          <a href="types/abaseclass.html?swift">ABaseClass</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/aderivedclass.html?swift">ADerivedClass</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/anenum.html?swift">AnEnum</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/firstprotocol1.html?swift">FirstProtocol</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/genericbase.html?swift">GenericBase</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/nop.html?swift">Nop</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types.html?swift#p1">P1</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types.html?swift#p2">P2</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/propertywrapperclient.html?swift">PropertyWrapperClient</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/s1.html?swift">S1</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/s2.html?swift">S2</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/secondprotocol.html?swift">SecondProtocol</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/spmswiftmodule.html?swift">SpmSwiftModule</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/spmswiftmodule/nested1.html?swift">- Nested1</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types/spmswiftmodule.html?swift#nested2">- Nested2</a>
        </li>
        
        <li class="nav-group-task">
          <a href="types.html?swift#t2">T</a>
        </li>
        
      </ul>
    </li>
    
    <li class="nav-group-name">
      <a href="functions.html?swift">Functions</a>
      <ul class="nav-group-tasks">
        
        <li class="nav-group-task">
          <a href="functions.html?swift#deprecatedfunctioncallback">deprecatedFunction(callback:)</a>
        </li>
        
        <li class="nav-group-task">
          <a href="functions.html?swift#functionaarg1_arg3">functionA(arg1:_:arg3:)</a>
        </li>
        
      </ul>
    </li>
    
    <li class="nav-group-name">
      <a href="operators.html?swift">Operators</a>
      <ul class="nav-group-tasks">
        
        <li class="nav-group-task">
          <a href="operators.html?swift#t-t">+(T, T)</a>
        </li>
        
      </ul>
    </li>
    
    <li class="nav-group-name">
      <a href="extensions.html?swift">Extensions</a>
      <ul class="nav-group-tasks">
        
        <li class="nav-group-task">
          <a href="extensions/array.html?swift">Array</a>
        </li>
        
        <li class="nav-group-task">
          <a href="extensions/collection.html?swift">Collection</a>
        </li>
        
        <li class="nav-group-task">
          <a href="extensions.html?swift#dictionary">Dictionary</a>
        </li>
        
        <li class="nav-group-task">
          <a href="extensions/stringelement.html?swift">String.Element</a>
        </li>
        
        <li class="nav-group-task">
          <a href="extensions/stringprotocol.html?swift">StringProtocol</a>
        </li>
        
      </ul>
    </li>
    
  </ul>
</nav>

      <article class="main-content">
        <section>
          <section class="section">
            <h1>Extensions</h1>
            


            
            
          </section>
          
<section class="section task-group-section">
  
  <div class="task-group">
  
  <ul>
    
    <li class="item">
      <div>
        <code>
        <a name="/array"></a>
        <a name="//apple_ref/cpp/Extension/extension Array" class="dashAnchor"></a>
        
        
        
        <a class="token" href="#/array"><span class="j2-item-secondary">extension </span>Array</a>
        
        
        </code>
        
        
      </div>
      <div class="height-container">
        <div class="pointer-container"></div>
        <section class="section">
          <div class="pointer"></div>
          


          
          <div class="abstract">
            <p>An ordered, random-access collection.</p><p>Arrays are one of the most commonly used data types in an app. You use arrays to organize your app’s data. Specifically, you use the <code>Array</code> type to hold elements of a single type, the array’s <code>Element</code> type. An array can store any kind of elements—from integers to strings to classes.</p>
<p>Swift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets. Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s <code>Element</code> type. For example:</p>
<pre><code class="language-swift">// An array of 'Int' elements
let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]

// An array of 'String' elements
let streets = [&quot;Albemarle&quot;, &quot;Brandywine&quot;, &quot;Chesapeake&quot;]

</code></pre>
<p>You can create an empty array by specifying the <code>Element</code> type of your array in the declaration. For example:</p>
<pre><code class="language-swift">// Shortened forms are preferred
var emptyDoubles: [Double] = []

// The full type name is also allowed
var emptyFloats: Array&lt;Float&gt; = Array()

</code></pre>
<p>If you need an array that is preinitialized with a fixed number of default values, use the <code>Array(repeating:count:)</code> initializer.</p>
<pre><code class="language-swift">var digitCounts = Array(repeating: 0, count: 10)
print(digitCounts)
// Prints &quot;[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]&quot;

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="accessing-array-values">
<span data-anchor-id="accessing-array-values">
Accessing Array Values
</span></h1>
<p>When you need to perform an operation on all of an array’s elements, use a <code>for</code>-<code>in</code> loop to iterate through the array’s contents.</p>
<pre><code class="language-swift">for street in streets {
    print(&quot;I don't live on \(street).&quot;)
}
// Prints &quot;I don't live on Albemarle.&quot;
// Prints &quot;I don't live on Brandywine.&quot;
// Prints &quot;I don't live on Chesapeake.&quot;

</code></pre>
<p>Use the <code>isEmpty</code> property to check quickly whether an array has any elements, or use the <code>count</code> property to find the number of elements in the array.</p>
<pre><code class="language-swift">if oddNumbers.isEmpty {
    print(&quot;I don't know any odd numbers.&quot;)
} else {
    print(&quot;I know \(oddNumbers.count) odd numbers.&quot;)
}
// Prints &quot;I know 8 odd numbers.&quot;

</code></pre>
<p>Use the <code>first</code> and <code>last</code> properties for safe access to the value of the array’s first and last elements. If the array is empty, these properties are <code>nil</code>.</p>
<pre><code class="language-swift">if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {
    print(firstElement, lastElement, separator: &quot;, &quot;)
}
// Prints &quot;1, 15&quot;

print(emptyDoubles.first, emptyDoubles.last, separator: &quot;, &quot;)
// Prints &quot;nil, nil&quot;

</code></pre>
<p>You can access individual array elements through a subscript. The first element of a nonempty array is always at index zero. You can subscript an array with any integer from zero up to, but not including, the count of the array. Using a negative number or an index equal to or greater than <code>count</code> triggers a runtime error. For example:</p>
<pre><code class="language-swift">print(oddNumbers[0], oddNumbers[3], separator: &quot;, &quot;)
// Prints &quot;1, 7&quot;

print(emptyDoubles[0])
// Triggers runtime error: Index out of range

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="adding-and-removing-elements">
<span data-anchor-id="adding-and-removing-elements">
Adding and Removing Elements
</span></h1>
<p>Suppose you need to store a list of the names of students that are signed up for a class you’re teaching. During the registration period, you need to add and remove names as students add and drop the class.</p>
<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;]

</code></pre>
<p>To add single elements to the end of an array, use the <code>append(_:)</code> method. Add multiple elements at the same time by passing another array or a sequence of any kind to the <code>append(contentsOf:)</code> method.</p>
<pre><code class="language-swift">students.append(&quot;Maxime&quot;)
students.append(contentsOf: [&quot;Shakia&quot;, &quot;William&quot;])
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]

</code></pre>
<p>You can add new elements in the middle of an array by using the <code>insert(_:at:)</code> method for single elements and by using <code>insert(contentsOf:at:)</code> to insert multiple elements from another collection or array literal. The elements at that index and later indices are shifted back to make room.</p>
<pre><code class="language-swift">students.insert(&quot;Liam&quot;, at: 3)
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]

</code></pre>
<p>To remove elements from an array, use the <code>remove(at:)</code>, <code>removeSubrange(_:)</code>, and <code>removeLast()</code> methods.</p>
<pre><code class="language-swift">// Ben's family is moving to another state
students.remove(at: 0)
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]

// William is signing up for a different class
students.removeLast()
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;]

</code></pre>
<p>You can replace an existing element with a new value by assigning the new value to the subscript.</p>
<pre><code class="language-swift">if let i = students.firstIndex(of: &quot;Maxime&quot;) {
    students[i] = &quot;Max&quot;
}
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Max&quot;, &quot;Shakia&quot;]

</code></pre>
<h2 class="j2-anchor j2-heading heading" id="growing-the-size-of-an-array">
<span data-anchor-id="growing-the-size-of-an-array">
Growing the Size of an Array
</span></h2>
<p>Every array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.</p>
<p>If you know approximately how many elements you will need to store, use the <code>reserveCapacity(_:)</code> method before appending to the array to avoid intermediate reallocations. Use the <code>capacity</code> and <code>count</code> properties to determine how many more elements the array can store without allocating larger storage.</p>
<p>For arrays of most <code>Element</code> types, this storage is a contiguous block of memory. For arrays with an <code>Element</code> type that is a class or <code>@objc</code> protocol type, this storage can be a contiguous block of memory or an instance of <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a>. Because any arbitrary subclass of <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> can become an <code>Array</code>, there are no guarantees about representation or efficiency in this case.</p>
<h1 class="j2-anchor j2-heading heading" id="modifying-copies-of-arrays">
<span data-anchor-id="modifying-copies-of-arrays">
Modifying Copies of Arrays
</span></h1>
<p>Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array. For example:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var numbersCopy = numbers
numbers[0] = 100
print(numbers)
// Prints &quot;[100, 2, 3, 4, 5]&quot;
print(numbersCopy)
// Prints &quot;[1, 2, 3, 4, 5]&quot;

</code></pre>
<p>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. For example:</p>
<pre><code class="language-swift">// An integer type with reference semantics
class IntegerReference {
    var value = 10
}
var firstIntegers = [IntegerReference(), IntegerReference()]
var secondIntegers = firstIntegers

// Modifications to an instance are visible from either array
firstIntegers[0].value = 100
print(secondIntegers[0].value)
// Prints &quot;100&quot;

// Replacements, additions, and removals are still visible
// only in the modified array
firstIntegers[0] = IntegerReference()
print(firstIntegers[0].value)
// Prints &quot;10&quot;
print(secondIntegers[0].value)
// Prints &quot;100&quot;

</code></pre>
<p>Arrays, like all variable-size collections in the standard library, use copy-on-write optimization. Multiple copies of an array share the same storage until you modify one of the copies. When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place. Optimizations are sometimes applied that can reduce the amount of copying.</p>
<p>This means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array. An array that is the sole owner of its storage can perform mutating operations in place.</p>
<p>In the example below, a <code>numbers</code> array is created along with two copies that share the same storage. When the original <code>numbers</code> array is modified, it makes a unique copy of its storage before making the modification. Further modifications to <code>numbers</code> are made in place, while the two copies continue to share the original storage.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var firstCopy = numbers
var secondCopy = numbers

// The storage for 'numbers' is copied here
numbers[0] = 100
numbers[1] = 200
numbers[2] = 300
// 'numbers' is [100, 200, 300, 4, 5]
// 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="bridging-between-array-and-nsarray">
<span data-anchor-id="bridging-between-array-and-nsarray">
Bridging Between Array and NSArray
</span></h1>
<p>When you need to access APIs that require data in an <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> instance instead of <code>Array</code>, use the type-cast operator (<code>as</code>) to bridge your instance. For bridging to be possible, the <code>Element</code> type of your array must be a class, an <code>@objc</code> protocol (a protocol imported from Objective-C or marked with the <code>@objc</code> attribute), or a type that bridges to a Foundation type.</p>
<p>The following example shows how you can bridge an <code>Array</code> instance to <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> to use the <code>write(to:atomically:)</code> method. In this example, the <code>colors</code> array can be bridged to <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> because the <code>colors</code> array’s <a href="https://developer.apple.com/documentation/swift/string?language=swift" class="j2-swift"><code>String</code></a><a href="https://developer.apple.com/documentation/swift/string?language=objc" class="j2-objc j2-secondary"><code>String</code></a> elements bridge to <a href="https://developer.apple.com/documentation/foundation/nsstring?language=swift" class="j2-swift"><code>NSString</code></a><a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc" class="j2-objc j2-secondary"><code>NSString</code></a>. The compiler prevents bridging the <code>moreColors</code> array, on the other hand, because its <code>Element</code> type is <code>&gt;</code>, which does <em>not</em> bridge to a Foundation type.</p>
<pre><code class="language-swift">let colors = [&quot;periwinkle&quot;, &quot;rose&quot;, &quot;moss&quot;]
let moreColors: [String?] = [&quot;ochre&quot;, &quot;pine&quot;]

let url = URL(fileURLWithPath: &quot;names.plist&quot;)
(colors as NSArray).write(to: url, atomically: true)
// true

(moreColors as NSArray).write(to: url, atomically: true)
// error: cannot convert value of type '[String?]' to type 'NSArray'

</code></pre>
<p>Bridging from <code>Array</code> to <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> takes O(1) time and O(1) space if the array’s elements are already instances of a class or an <code>@objc</code> protocol; otherwise, it takes O(<em>n</em>) time and space.</p>
<p>When the destination array’s element type is a class or an <code>@objc</code> protocol, bridging from <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> to <code>Array</code> first calls the <code>copy(with:)</code> (<code>- copyWithZone:</code> in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> that are already immutable, <code>copy(with:)</code> usually returns the same array in O(1) time; otherwise, the copying performance is unspecified. If <code>copy(with:)</code> returns the same array, the instances of <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> and <code>Array</code> share storage using the same copy-on-write optimization that is used when two instances of <code>Array</code> share storage.</p>
<p>When the destination array’s element type is a nonclass type that bridges to a Foundation type, bridging from <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> to <code>Array</code> performs a bridging copy of the elements to contiguous storage in O(<em>n</em>) time. For example, bridging from <a href="https://developer.apple.com/documentation/foundation/nsarray?language=swift" class="j2-swift"><code>NSArray</code></a><a href="https://developer.apple.com/documentation/foundation/nsarray?language=objc" class="j2-objc j2-secondary"><code>NSArray</code></a> to <code>&gt;</code> performs such a copy. No further bridging is required when accessing elements of the <code>Array</code> instance.</p>
<div class="j2-callout j2-callout-note aside aside-note">
<div class="j2-callout-title aside-title" role="heading" aria-level="6">note</div>
<p>The <code>ContiguousArray</code> and <a href="https://developer.apple.com/documentation/swift/arrayslice?language=swift" class="j2-swift"><code>ArraySlice</code></a><a href="https://developer.apple.com/documentation/swift/arrayslice?language=objc" class="j2-objc j2-secondary"><code>ArraySlice</code></a> types are not bridged; instances of those types always have a contiguous block of memory as their storage.</p>
</div>
            
            <a href="extensions/array.html?swift" class="slightly-smaller">See more</a>
            
          </div>
          
          
          
          <div class="declaration">
            <h4>Declaration</h4>
            <div class="language">
              <p class="aside-title">Swift</p>
              <pre><code class="language-swift">extension <a href="https://developer.apple.com/documentation/swift/array?language=swift">Array</a>: <a href="types.html?swift#p1">P1</a> where Element: <a href="https://developer.apple.com/documentation/swift/comparable?language=swift">Comparable</a></code></pre>
            </div>
            
          </div>
          
          
          
          
          <div class="slightly-smaller">
            <a href="http://www.bbc.co.uk//Sources/SpmSwiftModule/Protocols.swift#L72-L74">Show on GitHub</a>
          </div>
          
        </section>
        
      </div>
    </li>
    
    <li class="item">
      <div>
        <code>
        <a name="/collection"></a>
        <a name="//apple_ref/cpp/Extension/extension Collection" class="dashAnchor"></a>
        
        
        
        <a class="token" href="#/collection"><span class="j2-item-secondary">extension </span>Collection</a>
        
        
        </code>
        
        
      </div>
      <div class="height-container">
        <div class="pointer-container"></div>
        <section class="section">
          <div class="pointer"></div>
          


          
          <div class="abstract">
            <p>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.</p><p>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <code>Collection</code> protocol declares and implements. In addition to the operations that collections inherit from the <a href="https://developer.apple.com/documentation/swift/sequence?language=swift" class="j2-swift"><code>Sequence</code></a><a href="https://developer.apple.com/documentation/swift/sequence?language=objc" class="j2-objc j2-secondary"><code>Sequence</code></a> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.</p>
<p>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.</p>
<pre><code class="language-swift">let text = &quot;Buffalo buffalo buffalo buffalo.&quot;
if let firstSpace = text.firstIndex(of: &quot; &quot;) {
    print(text[..&lt;firstSpace])
}
// Prints &quot;Buffalo&quot;

</code></pre>
<p>The <code>firstSpace</code> constant is an index into the <code>text</code> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <code>firstSpace</code> is used to extract the prefix that contains elements up to that index.</p>
<h1 class="j2-anchor j2-heading heading" id="accessing-individual-elements">
<span data-anchor-id="accessing-individual-elements">
Accessing Individual Elements
</span></h1>
<p>You can access an element of a collection through its subscript by using any valid index except the collection’s <code>endIndex</code> property. This property is a “past the end” index that does not correspond with any element of the collection.</p>
<p>Here’s an example of accessing the first character in a string through its subscript:</p>
<pre><code class="language-swift">let firstChar = text[text.startIndex]
print(firstChar)
// Prints &quot;B&quot;

</code></pre>
<p>The <code>Collection</code> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <code>text</code> using the <code>first</code> property, which has the value of the first element of the collection, or <code>nil</code> if the collection is empty.</p>
<pre><code class="language-swift">print(text.first)
// Prints &quot;Optional(&quot;B&quot;)&quot;

</code></pre>
<p>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <code>startIndex</code> property and finding every successor up to, and including, the <code>endIndex</code> property. All other values of the <code>Index</code> type, such as the <code>startIndex</code> property of a different collection, are invalid indices for this collection.</p>
<p>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <a href="https://developer.apple.com/documentation/swift/mutablecollection?language=swift" class="j2-swift"><code>MutableCollection</code></a><a href="https://developer.apple.com/documentation/swift/mutablecollection?language=objc" class="j2-objc j2-secondary"><code>MutableCollection</code></a> and <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection?language=swift" class="j2-swift"><code>RangeReplaceableCollection</code></a><a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection?language=objc" class="j2-objc j2-secondary"><code>RangeReplaceableCollection</code></a> protocols, as well as for the specific type you’re using.</p>
<h1 class="j2-anchor j2-heading heading" id="accessing-slices-of-a-collection">
<span data-anchor-id="accessing-slices-of-a-collection">
Accessing Slices of a Collection
</span></h1>
<p>You can access a slice of a collection through its ranged subscript or by calling methods like <code>prefix(while:)</code> or <code>suffix(_:)</code>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.</p>
<p>The following example creates a <code>firstWord</code> constant by using the <code>prefix(while:)</code> method to get a slice of the <code>text</code> string.</p>
<pre><code class="language-swift">let firstWord = text.prefix(while: { $0 != &quot; &quot; })
print(firstWord)
// Prints &quot;Buffalo&quot;

</code></pre>
<p>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.</p>
<pre><code class="language-swift">if let firstSpace = text.firstIndex(of: &quot; &quot;) {
    print(text[..&lt;firstSpace])
    // Prints &quot;Buffalo&quot;
}

</code></pre>
<p>The retrieved slice of <code>text</code> is equivalent in each of these cases.</p>
<h2 class="j2-anchor j2-heading heading" id="slices-share-indices">
<span data-anchor-id="slices-share-indices">
Slices Share Indices
</span></h2>
<p>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.</p>
<p>For example, suppose you have an array holding the number of absences from each class during a session.</p>
<pre><code class="language-swift">var absences = [0, 2, 0, 4, 0, 3, 1, 0]

</code></pre>
<p>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:</p>
<ol>
<li>Create a slice of the <code>absences</code> array that holds the second half of the days.</li>
<li>Use the <code>max(by:)</code> method to determine the index of the day with the most absences.</li>
<li>Print the result using the index found in step 2 on the original <code>absences</code> array.</li>
</ol>
<p>Here’s an implementation of those steps:</p>
<pre><code class="language-swift">let secondHalf = absences.suffix(absences.count / 2)
if let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {
    print(&quot;Highest second-half absences: \(absences[i])&quot;)
}
// Prints &quot;Highest second-half absences: 3&quot;

</code></pre>
<h2 class="j2-anchor j2-heading heading" id="slices-inherit-collection-semantics">
<span data-anchor-id="slices-inherit-collection-semantics">
Slices Inherit Collection Semantics
</span></h2>
<p>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.</p>
<p>For example, if you update the last element of the <code>absences</code> array from <code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.</p>
<pre><code class="language-swift">absences[7] = 2
print(absences)
// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;
print(secondHalf)
// Prints &quot;[0, 3, 1, 0]&quot;

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="traversing-a-collection">
<span data-anchor-id="traversing-a-collection">
Traversing a Collection
</span></h1>
<p>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <em>multipass</em>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <code>contains(_:)</code> method to test whether a collection includes an element.</p>
<p>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <code>characters</code> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.</p>
<pre><code class="language-swift">let word = &quot;Swift&quot;
for character in word {
    print(character)
}
// Prints &quot;S&quot;
// Prints &quot;w&quot;
// Prints &quot;i&quot;
// Prints &quot;f&quot;
// Prints &quot;t&quot;

for i in word.indices {
    print(word[i])
}
// Prints &quot;S&quot;
// Prints &quot;w&quot;
// Prints &quot;i&quot;
// Prints &quot;f&quot;
// Prints &quot;t&quot;

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="conforming-to-the-collection-protocol">
<span data-anchor-id="conforming-to-the-collection-protocol">
Conforming to the Collection Protocol
</span></h1>
<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <code>Collection</code> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <code>Collection</code> conformance to your type, you must declare at least the following requirements:</p>
<ul>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your type’s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
</ul>
<h1 class="j2-anchor j2-heading heading" id="expected-performance">
<span data-anchor-id="expected-performance">
Expected Performance
</span></h1>
<p>Types that conform to <code>Collection</code> are expected to provide the <code>startIndex</code> and <code>endIndex</code> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.</p>
<p>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <code>count</code> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <code>count</code> property is an O(<em>n</em>) operation.</p>
            
            <a href="extensions/collection.html?swift" class="slightly-smaller">See more</a>
            
          </div>
          
          
          
          <div class="declaration">
            <h4>Declaration</h4>
            <div class="language">
              <p class="aside-title">Swift</p>
              <pre><code class="language-swift">extension <a href="https://developer.apple.com/documentation/swift/collection?language=swift">Collection</a> where Element: <a href="types/firstprotocol1.html?swift">FirstProtocol</a>

extension <a href="https://developer.apple.com/documentation/swift/collection?language=swift">Collection</a> where Element == <a href="types/spmswiftmodule/nested1.html?swift">SpmSwiftModule.Nested1</a></code></pre>
            </div>
            
          </div>
          
          
          
          
          <div class="slightly-smaller">
            <a href="http://www.bbc.co.uk//Sources/SpmSwiftModule/Extensions.swift#L38-L40">Show on GitHub</a>
          </div>
          
        </section>
        
      </div>
    </li>
    
    <li class="item">
      <div>
        <code>
        <a name="/dictionary"></a>
        <a name="//apple_ref/cpp/Extension/extension Dictionary" class="dashAnchor"></a>
        
        
        
        <a class="token" href="#/dictionary"><span class="j2-item-secondary">extension </span>Dictionary</a>
        
        
        </code>
        
        
      </div>
      <div class="height-container">
        <div class="pointer-container"></div>
        <section class="section">
          <div class="pointer"></div>
          


          
          <div class="abstract">
            <p>A collection whose elements are key-value pairs.</p><p>A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays.</p>
<p>Create a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.</p>
<p>Here’s how you would create a dictionary of HTTP response codes and their related messages:</p>
<pre><code class="language-swift">var responseMessages = [200: &quot;OK&quot;,
                        403: &quot;Access forbidden&quot;,
                        404: &quot;File not found&quot;,
                        500: &quot;Internal server error&quot;]

</code></pre>
<p>The <code>responseMessages</code> variable is inferred to have type <code>[Int: String]</code>. The <code>Key</code> type of the dictionary is <a href="https://developer.apple.com/documentation/swift/int?language=swift" class="j2-swift"><code>Int</code></a><a href="https://developer.apple.com/documentation/swift/int?language=objc" class="j2-objc j2-secondary"><code>Int</code></a>, and the <code>Value</code> type of the dictionary is <a href="https://developer.apple.com/documentation/swift/string?language=swift" class="j2-swift"><code>String</code></a><a href="https://developer.apple.com/documentation/swift/string?language=objc" class="j2-objc j2-secondary"><code>String</code></a>.</p>
<p>To create a dictionary with no key-value pairs, use an empty dictionary literal (<code>[:]</code>).</p>
<pre><code class="language-swift">var emptyDict: [String: String] = [:]

</code></pre>
<p>Any type that conforms to the <a href="https://developer.apple.com/documentation/swift/hashable?language=swift" class="j2-swift"><code>Hashable</code></a><a href="https://developer.apple.com/documentation/swift/hashable?language=objc" class="j2-objc j2-secondary"><code>Hashable</code></a> protocol can be used as a dictionary’s <code>Key</code> type, including all of Swift’s basic types. You can use your own custom types as dictionary keys by making them conform to the <a href="https://developer.apple.com/documentation/swift/hashable?language=swift" class="j2-swift"><code>Hashable</code></a><a href="https://developer.apple.com/documentation/swift/hashable?language=objc" class="j2-objc j2-secondary"><code>Hashable</code></a> protocol.</p>
<h1 class="j2-anchor j2-heading heading" id="getting-and-setting-dictionary-values">
<span data-anchor-id="getting-and-setting-dictionary-values">
Getting and Setting Dictionary Values
</span></h1>
<p>The most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:</p>
<pre><code class="language-swift">print(responseMessages[200])
// Prints &quot;Optional(&quot;OK&quot;)&quot;

</code></pre>
<p>Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.</p>
<p>The next example uses key-based subscripting of the <code>responseMessages</code> dictionary with two keys that exist in the dictionary and one that does not.</p>
<pre><code class="language-swift">let httpResponseCodes = [200, 403, 301]
for code in httpResponseCodes {
    if let message = responseMessages[code] {
        print(&quot;Response \(code): \(message)&quot;)
    } else {
        print(&quot;Unknown response \(code)&quot;)
    }
}
// Prints &quot;Response 200: OK&quot;
// Prints &quot;Response 403: Access forbidden&quot;
// Prints &quot;Unknown response 301&quot;

</code></pre>
<p>You can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isn’t yet a part of the dictionary.</p>
<pre><code class="language-swift">responseMessages[301] = &quot;Moved permanently&quot;
print(responseMessages[301])
// Prints &quot;Optional(&quot;Moved permanently&quot;)&quot;

</code></pre>
<p>Update an existing value by assigning a new value to a key that already exists in the dictionary. If you assign <code>nil</code> to an existing key, the key and its associated value are removed. The following example updates the value for the <code>404</code> code to be simply “Not found” and removes the key-value pair for the <code>500</code> code entirely.</p>
<pre><code class="language-swift">responseMessages[404] = &quot;Not found&quot;
responseMessages[500] = nil
print(responseMessages)
// Prints &quot;[301: &quot;Moved permanently&quot;, 200: &quot;OK&quot;, 403: &quot;Access forbidden&quot;, 404: &quot;Not found&quot;]&quot;

</code></pre>
<p>In a mutable <code>Dictionary</code> instance, you can modify in place a value that you’ve accessed through a keyed subscript. The code sample below declares a dictionary called <code>interestingNumbers</code> with string keys and values that are integer arrays, then sorts each array in-place in descending order.</p>
<pre><code class="language-swift">var interestingNumbers = [&quot;primes&quot;: [2, 3, 5, 7, 11, 13, 17],
                          &quot;triangular&quot;: [1, 3, 6, 10, 15, 21, 28],
                          &quot;hexagonal&quot;: [1, 6, 15, 28, 45, 66, 91]]
for key in interestingNumbers.keys {
    interestingNumbers[key]?.sort(by: &gt;)
}

print(interestingNumbers[&quot;primes&quot;]!)
// Prints &quot;[17, 13, 11, 7, 5, 3, 2]&quot;

</code></pre>
<h1 class="j2-anchor j2-heading heading" id="iterating-over-the-contents-of-a-dictionary">
<span data-anchor-id="iterating-over-the-contents-of-a-dictionary">
Iterating Over the Contents of a Dictionary
</span></h1>
<p>Every dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using a <code>for</code>-<code>in</code> loop, decomposing each key-value pair into the elements of a tuple.</p>
<pre><code class="language-swift">let imagePaths = [&quot;star&quot;: &quot;/glyphs/star.png&quot;,
                  &quot;portrait&quot;: &quot;/images/content/portrait.jpg&quot;,
                  &quot;spacer&quot;: &quot;/images/shared/spacer.gif&quot;]

for (name, path) in imagePaths {
    print(&quot;The path to '\(name)' is '\(path)'.&quot;)
}
// Prints &quot;The path to 'star' is '/glyphs/star.png'.&quot;
// Prints &quot;The path to 'portrait' is '/images/content/portrait.jpg'.&quot;
// Prints &quot;The path to 'spacer' is '/images/shared/spacer.gif'.&quot;

</code></pre>
<p>The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and don’t need the fast key lookup that <code>Dictionary</code> provides, see the <a href="https://developer.apple.com/documentation/swift/keyvaluepairs?language=swift" class="j2-swift"><code>KeyValuePairs</code></a><a href="https://developer.apple.com/documentation/swift/keyvaluepairs?language=objc" class="j2-objc j2-secondary"><code>KeyValuePairs</code></a> type for an alternative.</p>
<p>You can search a dictionary’s contents for a particular value using the <code>contains(where:)</code> or <code>firstIndex(where:)</code> methods supplied by default implementation. The following example checks to see if <code>imagePaths</code> contains any paths in the <code>&quot;</code> directory:</p>
<pre><code class="language-swift">let glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix(&quot;/glyphs&quot;) })
if let index = glyphIndex {
    print(&quot;The '\(imagePaths[index].key)' image is a glyph.&quot;)
} else {
    print(&quot;No glyphs found!&quot;)
}
// Prints &quot;The 'star' image is a glyph.&quot;

</code></pre>
<p>Note that in this example, <code>imagePaths</code> is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple.</p>
<pre><code class="language-swift">print(imagePaths[glyphIndex!])
// Prints &quot;(key: &quot;star&quot;, value: &quot;/glyphs/star.png&quot;)&quot;

</code></pre>
<p>A dictionary’s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.</p>
<p>When you know how many new values you’re adding to a dictionary, use the <code>init(minimumCapacity:)</code> initializer to allocate the correct amount of buffer.</p>
<h1 class="j2-anchor j2-heading heading" id="bridging-between-dictionary-and-nsdictionary">
<span data-anchor-id="bridging-between-dictionary-and-nsdictionary">
Bridging Between Dictionary and NSDictionary
</span></h1>
<p>You can bridge between <code>Dictionary</code> and <code>NSDictionary</code> using the <code>as</code> operator. For bridging to be possible, the <code>Key</code> and <code>Value</code> types of a dictionary must be classes, <code>@objc</code> protocols, or types that bridge to Foundation types.</p>
<p>Bridging from <code>Dictionary</code> to <code>NSDictionary</code> always takes O(1) time and space. When the dictionary’s <code>Key</code> and <code>Value</code> types are neither classes nor <code>@objc</code> protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O(<em>n</em>).</p>
<p>Bridging from <code>NSDictionary</code> to <code>Dictionary</code> first calls the <code>copy(with:)</code> method (<code>- copyWithZone:</code> in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <code>NSDictionary</code> that are already immutable, <code>copy(with:)</code> usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances of <code>NSDictionary</code> and <code>Dictionary</code> share buffer using the same copy-on-write optimization that is used when two instances of <code>Dictionary</code> share buffer.</p>
            
          </div>
          
          
          
          <div class="declaration">
            <h4>Declaration</h4>
            <div class="language">
              <p class="aside-title">Swift</p>
              <pre><code class="language-swift">extension <a href="https://developer.apple.com/documentation/swift/dictionary?language=swift">Dictionary</a>: <a href="types.html?swift#p2">P2</a></code></pre>
            </div>
            
          </div>
          
          
          
          
          <div class="slightly-smaller">
            <a href="http://www.bbc.co.uk//Sources/SpmSwiftModule/Protocols.swift#L70">Show on GitHub</a>
          </div>
          
        </section>
        
      </div>
    </li>
    
    <li class="item">
      <div>
        <code>
        <a name="/stringelement"></a>
        <a name="//apple_ref/cpp/Extension/extension String.Element" class="dashAnchor"></a>
        
        
        
        <a class="token" href="#/stringelement"><span class="j2-item-secondary">extension </span>String.Element</a>
        
        
        </code>
        
        
      </div>
      <div class="height-container">
        <div class="pointer-container"></div>
        <section class="section">
          <div class="pointer"></div>
          


          
          <div class="abstract">
            <p>Extension of a nested type from an external module</p>
            
            <a href="extensions/stringelement.html?swift" class="slightly-smaller">See more</a>
            
          </div>
          
          
          
          <div class="declaration">
            <h4>Declaration</h4>
            <div class="language">
              <p class="aside-title">Swift</p>
              <pre><code class="language-swift">extension String.Element</code></pre>
            </div>
            
          </div>
          
          
          
          
          <div class="slightly-smaller">
            <a href="http://www.bbc.co.uk//Sources/SpmSwiftModule/Extensions.swift#L56-L61">Show on GitHub</a>
          </div>
          
        </section>
        
      </div>
    </li>
    
    <li class="item">
      <div>
        <code>
        <a name="/stringprotocol"></a>
        <a name="//apple_ref/cpp/Extension/extension StringProtocol" class="dashAnchor"></a>
        
        
        
        <a class="token" href="#/stringprotocol"><span class="j2-item-secondary">extension </span>StringProtocol</a>
        
        
        </code>
        
        
      </div>
      <div class="height-container">
        <div class="pointer-container"></div>
        <section class="section">
          <div class="pointer"></div>
          


          
          <div class="abstract">
            <p>A type that can represent a string as a collection of characters.</p><p>Do not declare new conformances to <code>StringProtocol</code>. Only the <a href="https://developer.apple.com/documentation/swift/string?language=swift" class="j2-swift"><code>String</code></a><a href="https://developer.apple.com/documentation/swift/string?language=objc" class="j2-objc j2-secondary"><code>String</code></a> and <a href="https://developer.apple.com/documentation/swift/substring?language=swift" class="j2-swift"><code>Substring</code></a><a href="https://developer.apple.com/documentation/swift/substring?language=objc" class="j2-objc j2-secondary"><code>Substring</code></a> types in the standard library are valid conforming types.</p>
            
            <a href="extensions/stringprotocol.html?swift" class="slightly-smaller">See more</a>
            
          </div>
          
          
          
          <div class="declaration">
            <h4>Declaration</h4>
            <div class="language">
              <p class="aside-title">Swift</p>
              <pre><code class="language-swift">extension <a href="https://developer.apple.com/documentation/swift/stringprotocol?language=swift">StringProtocol</a></code></pre>
            </div>
            
          </div>
          
          
          
          
          <div class="slightly-smaller">
            <a href="http://www.bbc.co.uk//Sources/SpmSwiftModule/Extensions.swift#L63-L67">Show on GitHub</a>
          </div>
          
        </section>
        
      </div>
    </li>
    
  </ul>
</div>

  
</section>


        </section>
        <section id="footer">
  <p>© 9999. All rights reserved. (Last updated: today).</p>
  <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ vBebop 1.0</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
</section>

      </article>
    </div>
  </body>
</div>
</html>
